# -*- coding: utf-8 -*-

# Copyright 2018 IBM.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# =============================================================================

import logging
import numpy as np
import functools

from qiskit.aqua.utils.backend_utils import is_aer_statevector_backend
from qiskit.aqua.components.gradients import Gradient

logger = logging.getLogger(__name__)


class OperatorGradient(Gradient):
    CONFIGURATION = {
        'name': 'OperatorGradient',
        'description': 'OperatorGradient extension',
        'input_schema': {
            '$schema': 'http://json-schema.org/schema#',
            'id': 'gradient_schema',
            'type': 'object',
            'properties': {
            },
            'additionalProperties': False
        }
    }

    def __init__(self, params=None):
        super().__init__()


    def _get_cost(self, parameters): #todo eval count logger
        """Compute the objective/cost value for each data point theta.
        Internally, we construct the circuits to evaluate <phi| H | phi>, where |phi> denotes the ansatz generated by the varitional form. H represents the operator.

        Args:
            parameters (ndarray): 1-d array that represents the parameter values
        Returns:
            float: the objective/cost value
        """
        num_parameter_sets = len(parameters) // self._var_form.num_parameters
        circuits = []
        parameter_sets = np.split(parameters, num_parameter_sets)
        mean_energy = []
        std_energy = []

        for idx in range(len(parameter_sets)):
            parameter = parameter_sets[idx]
            input_circuit = self._var_form.construct_circuit(parameter)
            circuit = self._operator.construct_evaluation_circuit(self._operator_mode,
                                                              input_circuit, self._quantum_instance.backend, self._use_simulator_operator_mode)
            circuits.append(circuit)

        to_be_simulated_circuits = functools.reduce(lambda x, y: x + y, circuits)
        if self._use_simulator_operator_mode:
            extra_args = {'expectation': {
                'params': [self._operator.aer_paulis],
                'num_qubits': self._operator.num_qubits}
            }
        else:
            extra_args = {}
        result = self._quantum_instance.execute(to_be_simulated_circuits, **extra_args)

        for idx in range(len(parameter_sets)):
            mean, std = self._operator.evaluate_with_result(
                self._operator_mode, circuits[idx], self._quantum_instance.backend, result, self._use_simulator_operator_mode)
            mean_energy.append(np.real(mean))
            std_energy.append(np.real(std))
            # self._eval_count += 1
            # if self._callback is not None:
            #     self._callback(self._eval_count, parameter_sets[idx], np.real(mean), np.real(std))
            # logger.info('Energy evaluation {} returned {}'.format(self._eval_count, np.real(mean)))

        return mean_energy if len(mean_energy) > 1 else mean_energy[0]

    def get_gradient_function(self, var_form, operator, quantum_instance, operator_mode):
        """Return the gradient function for computing the gradient at a point
        Args:
            var_form (VariationalForm): the variational form instance
            operator (Operator): the Operator instance
            quantum_instance (QuantumInstance): QuantumInstance for the execution
            operator_mode (str): operator mode
        Returns:
            func: the gradient function for computing the gradient at a point
        """
        self._var_form = var_form
        self._operator = operator
        self._quantum_instance = quantum_instance
        self._operator_mode = operator_mode
        self._use_simulator_operator_mode = \
            is_aer_statevector_backend(self._quantum_instance.backend) \
            and self._operator_mode != 'matrix'
        self.objective_function = self._get_cost


        def gradient_num_diff(x_center):
            """
            We compute the gradient with the numeric differentiation  around the point x_center.
            Args:
                x_center (ndarray): point around which we compute the gradient
            Returns:
                grad: the gradient computed
            """
            epsilon = 1e-8
            forig = self.objective_function(*((x_center,)))
            grad = []
            ei = np.zeros((len(x_center),), float)
            todos = []
            for k in range(len(x_center)):
                ei[k] = 1.0
                d = epsilon * ei
                todos.append(x_center + d)
                deriv = (self.objective_function(x_center + d) - forig)/epsilon
                grad.append(deriv)
                ei[k] = 0.0
            return np.array(grad)

        return gradient_num_diff
